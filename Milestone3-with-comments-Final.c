
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  ultra,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  button1,        sensorTouch)
#pragma config(Sensor, dgtl4,  button2,        sensorTouch)
#pragma config(Sensor, dgtl5,  limit1,         sensorTouch)
#pragma config(Sensor, dgtl6,  limit2,         sensorTouch)
#pragma config(Sensor, dgtl11, LED2,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, LED1,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           drive1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           cable,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          drive2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* ENGR 120 2017 Uvic
*  Group 142
*  Code for MileStone 3
*  Authors: Kahvi Patel, Victor Sun, and Jonah Koebernick
*/

/******************************************************Start of Code*****************************************************/

#define EXERCISE_NUMBER 	1
const   int IR_SENSOR_THRESHOLD =600; // IR threhold for first approximation
const int light_threshold = 15; // IR threshold for monitorliight()

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 inout
bool limit1_pushed;  //flag to store limit1 input
bool limit2_pushed;  //flag to store limit2 inut
const int OFF = 0;   //LED off state
const int ON  = 1;   //LED ON state
int minlevel = 0;    //Measure of min IR reading
int maxlevel = 4095; //Measure of Max IR reading
int difflevel = 0;   //the different in IR reading

/********************************************************START OF FUNCTIONS**************************************************/

/* monitorInput()
*  Used to flag button inputs
*  this avoids errors caused by program recognizing input, taking action, and
*  reading input again before button is released
*/
void monitorInput(){
	if(SensorValue(button1)){
		button1_pushed = true;
	}
	if(SensorValue(button2)){

	button2_pushed = true;
}
}

/* AvoidWalls()
* Used to avoid walls
* Used to monitor the input of the limit stwitches
* If a limit switch is hit it corrects the course
*/
void AvoidWalls()
{
if(SensorValue(limit1)){
    	  motor[drive1] = 30;
    	  sleep(100);
    	  motor[drive1] = 45;
    	  motor[drive2] = -45;
    	  sleep(300);


			}
			if(SensorValue(limit2)){
    	  motor[drive1] = 30;
    	  sleep(100);
    	  motor[drive1] = 45;
    	  motor[drive2] = -45;
    	  sleep(300);


			}
			sleep(100);
			if(getMotorEncoder(cable)==0){
				limit1_pushed = true;
			}
}


/* Monitorlight()
* Used to ensure that the IR source is the beacon
* Return true if its the beacon
* Returns false if its no the beacon
*/
bool monitorlight(){
	bool returnvalue;
	int lightlevel= SensorValue[InfraCollector];
	if( time1[T1] > 100){
		difflevel = maxlevel-minlevel;
		maxlevel = 4095;
		minlevel = 0;
		clearTimer(T1);
	}
	if( time1[T1] <100){
		if( lightlevel < minlevel){
			minlevel = lightlevel;
		}else if(lightlevel > maxlevel){
		maxlevel = lightlevel;
	}

	if( difflevel < light_threshold){
		returnvalue = false;
	}
	if( difflevel > minlevel){
		returnvalue = true;
	}
}
return (returnvalue);
}

/*init_light_status()
* Used to rest the LEDs to off state
*/
void init_light_status()
{
  SensorValue(LED1)= OFF;
  SensorValue(LED2)= OFF;
}

/* locatebeacon()
* Used to locate the diretion of the beacon
* Inputs the threshold desired
*/
void locatebeacon (int thethreshold){
			int diff =0;
	    motor[drive1] =0;
	    motor[drive2] =0;
	    clearTimer(timer4);
	    sleep(200);
			motor[drive1] = 35;
			motor[drive2] = 35;

		while(SensorValue(InfraCollector) < thethreshold-diff)//threshold to locate the beacon at
    		{
    			if(time1[timer4] >4000){ // reduces the threshold if it can't locate the beacon after one revolution
    				diff= diff+100;
    				clearTimer(timer4);


    		}

    		}
    	motor[drive1] = 0;
      motor[drive2] = 0;
   }

/* signal()
* Used to signal completion when the robot is in range
* and inline with the beacon
*/
void signal(){

       	SensorValue(LED1) = 0;
				SensorValue(LED2) = 0;
				clearTimer(timer3);
				while(time1[timer3] < 5000){
				SensorValue(LED1) = 1;
				sleep(500);
				SensorValue(LED1) = 0;
				SensorValue(LED2) = 1;
				sleep(500);
				SensorValue(LED2) = 0;
			}
  }
/* Bootup()
*Singal for proper bootup and code start
*/
void Bootup(){

        SensorValue(LED1) = 0;
				SensorValue(LED2) = 0;
				clearTimer(timer2);
				while(time1[timer2] < 3000){
				SensorValue(LED1) = 1;
				SensorValue(LED2) = 1;
				sleep(500);
				SensorValue(LED1) = 0;
				SensorValue(LED2) = 0;
				sleep(500);
}

}
/****************************************************** END OF FUNCTIONS ************************************************/


//Switch for code
void exercise_1()
{
	enum T_exercise1_state {
		MOTOR_STOP ,
		Approach_Beacon,
		find_beacon,
		Hit_wall,
		backup,
		hitback
	};

	T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();
		// Switch the states.
		switch(exercise1_state) {

	  /*STATE find_beacon
	  * Used to locate the beacon the first time
	  */
		case find_beacon:
			locatebeacon(IR_SENSOR_THRESHOLD);
     if(monitorlight()){
       exercise1_state = Approach_Beacon;
       SensorValue(LED2)= ON;

      }

			break;


    /*STATE MOTOR_STOP
    * Used to stop both motors
    * Turns the LED lights OFF
    * and checks if button1_pushed or button2_pushed is pushed
    */
		case MOTOR_STOP:
			motor[drive1] = 0;
			motor[drive2] = 0;
			motor[cable] = 0;
			init_light_status();
			if ( button1_pushed ) {
				exercise1_state = find_beacon;
				button1_pushed = false;
			}
			if ( button2_pushed ) {
				exercise1_state = Hit_wall;
				button2_pushed = false;
			}

			break;
		/*STATE Approach_Beacon
		* Checks the diatnce from the IR beacon
		* Rechecks and adjust the direction as the robot gets closer
		* the robot moves slower as it gets closer to the beacon
		*/
		case Approach_Beacon:
					SensorValue(LED1) = ON;
		    	motor[drive1] = -50;
    			motor[drive2] =  65;
			 while(SensorValue(ultra) > 100){

    		 }

    		  motor[drive1] = -40;
    			motor[drive2] =  55;
    		while(SensorValue(ultra) > 75){

    		}
    		locatebeacon(900); //readjust
    		  motor[drive1] = -30;
    			motor[drive2] =  45;
    		while(SensorValue(ultra) > 50){

    		}
    		locatebeacon(3500);  //readjust
      	sleep(100);
      	motor[drive1] = -30;
    		motor[drive2] =  45;
    		while(SensorValue(ultra) > 14){
    		}
    		motor[drive1] = 0;
    		motor[drive2] = 0;
    		button1_pushed = false;
  		  exercise1_state = MOTOR_STOP;
    		signal();
			break;

      /*STATE Hit_wall
      * used to demostrate that the robot can sense walls
      * if limit one or two is pushed it exits
      * if button1_pushed it goes into hitback state
      */
			case Hit_wall:
			resetMotorEncoder(cable);
			button2_pushed = false;
			motor[drive1] = -45;
    	motor[drive2] = 45;
    	if(SensorValue(limit1)){
    	  limit1_pushed = true;
			}
			if(SensorValue(limit2)){
    	  limit2_pushed = true;
			}
			sleep(25);
			if(getMotorEncoder(cable)==0){
				limit1_pushed = true;
			}
			if( limit1_pushed || limit2_pushed){
				exercise1_state = backup;
				limit1_pushed = false;
				limit2_pushed = false;
							}
			if(SensorValue(button1)){
				exercise1_state = hitback;
				button1_pushed = false;

		}

			break;

			/*STATE hitback
			* used to demostrate that the robot can sense when backs into a wall
			*
			*/
			case hitback:
			motor[drive1] = 25;
    	motor[drive2] = -25;
    	resetMotorEncoder(cable);
    	button1_pushed = false;
    	AvoidWalls();
			if( limit1_pushed || limit2_pushed){
				exercise1_state = backup;
				limit1_pushed = false;
				limit2_pushed = false;
							}


			break;

			case backup:

				motor[drive1] = 45;
    	  motor[drive2] = -45;
    	  sleep(300);
    	  exercise1_state = MOTOR_STOP;

    	  break;



		default:
		}

	}//end while
}




task main()
{
	Bootup();
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
	{
	case 1:
		exercise_1();
		break;
	default: //should never get here.
	} // end switch

}// end main

/****************************************************END OF CODE********************************************************/
